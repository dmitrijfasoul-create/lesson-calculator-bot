import osimport loggingfrom datetime import datetimefrom decimal import Decimal, ROUND_HALF_UP  # to match Excel's ROUND half-away-from-zerofrom telegram import Updatefrom telegram.ext import (    ApplicationBuilder,    CommandHandler,    MessageHandler,    filters,    ConversationHandler,    ContextTypes,)# Logginglogging.basicConfig(    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)ASK_DATE, ASK_DAYS, ASK_LESSONS = range(3)def round_half_away_from_zero(x: float) -> int:    """Excel-like ROUND(x,0): halves go away from zero."""    return int(Decimal(str(x)).quantize(Decimal("0"), rounding=ROUND_HALF_UP))# Pricing grid (Vilnius), applied to the FORECAST monthly lessons (not the partial)def get_price_per_lesson(monthly_forecast: int) -> int:    if monthly_forecast >= 9:        return 30    elif monthly_forecast == 8:        return 33    elif monthly_forecast >= 6:        return 35    elif monthly_forecast >= 4:        return 40    else:        return 50async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):    await update.message.reply_text(        "üëã Hello! I‚Äôm your lesson fee calculator.\n\n"        "Step 1/3 ‚Äî Enter the date of the first lesson (DD.MM.YYYY or YYYY-MM-DD)\n"        "Example: 19.09.2025"    )    return ASK_DATEasync def ask_days(update: Update, context: ContextTypes.DEFAULT_TYPE):    # Parse date in two common formats    date_str = (update.message.text or "").strip()    lesson_date = None    for fmt in ("%d.%m.%Y", "%Y-%m-%d"):        try:            lesson_date = datetime.strptime(date_str, fmt)            break        except ValueError:            continue    if not lesson_date:        await update.message.reply_text(            "‚ùå Invalid date format.\nPlease enter like 19.09.2025 or 2025-09-19."        )        return ASK_DATE    context.user_data["lesson_date"] = lesson_date    await update.message.reply_text(        "Step 2/3 ‚Äî How many days are in this month? (28, 29, 30, or 31)"    )    return ASK_DAYSasync def ask_lessons(update: Update, context: ContextTypes.DEFAULT_TYPE):    text = (update.message.text or "").strip()    if not text.isdigit() or int(text) not in (28, 29, 30, 31):        await update.message.reply_text("‚ùå Please enter 28, 29, 30, or 31.")        return ASK_DAYS    days_in_month = int(text)    lesson_date: datetime = context.user_data["lesson_date"]    if lesson_date.day > days_in_month:        await update.message.reply_text(            "‚ùå The first lesson day exceeds the number of days in this month.\n"            "Please re-enter the date or month length."        )        return ASK_DAYS    remaining_days = days_in_month - lesson_date.day + 1  # inclusive    proportion = remaining_days / days_in_month    # Store for the next step    context.user_data["days_in_month"] = days_in_month    context.user_data["remaining_days"] = remaining_days    context.user_data["proportion"] = proportion    await update.message.reply_text(        "Step 3/3 ‚Äî How many lessons does the student want to buy for the rest of this month?"    )    return ASK_LESSONSasync def calculate(update: Update, context: ContextTypes.DEFAULT_TYPE):    text = (update.message.text or "").strip()    if not text.isdigit() or int(text) <= 0:        await update.message.reply_text("‚ùå Please enter a positive whole number of lessons.")        return ASK_LESSONS    lessons_partial = int(text)    lesson_date: datetime = context.user_data["lesson_date"]    days_in_month = context.user_data["days_in_month"]    remaining_days = context.user_data["remaining_days"]    proportion = context.user_data["proportion"]    # Excel-like logic:    # monthly_forecast = ROUND( lessons_in_rest / proportion , 0 )    monthly_forecast = max(1, round_half_away_from_zero(lessons_partial / proportion))    price_per_lesson = get_price_per_lesson(monthly_forecast)    total_price = lessons_partial * price_per_lesson    response = (        f"üìÖ First lesson date: {lesson_date.strftime('%d.%m.%Y')}\n"        f"üìÜ Remaining days: {remaining_days} of {days_in_month} (ratio: {proportion:.2f})\n"        f"üéØ Monthly forecast (Excel-style): {monthly_forecast} lessons\n"        f"üíµ Price tier from forecast: {price_per_lesson} ‚Ç¨ / lesson\n"        f"üßÆ Partial-month lessons: {lessons_partial}\n"        f"üí∞ Total for this partial month: {total_price} ‚Ç¨"    )    await update.message.reply_text(response)    return ConversationHandler.ENDasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):    await update.message.reply_text("üö´ Cancelled.")    return ConversationHandler.ENDdef main():    token = os.getenv("TELEGRAM_TOKEN")    if not token:        print("‚ùå Error: please set TELEGRAM_TOKEN environment variable")        return    app = ApplicationBuilder().token(token).build()    conv = ConversationHandler(        entry_points=[CommandHandler("start", start)],        states={            ASK_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_days)],            ASK_DAYS: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_lessons)],            ASK_LESSONS: [MessageHandler(filters.TEXT & ~filters.COMMAND, calculate)],        },        fallbacks=[CommandHandler("cancel", cancel)],        allow_reentry=True,    )    app.add_handler(conv)    print("‚úÖ Bot is running. Press Ctrl+C to stop.")    app.run_polling()if __name__ == "__main__":    main()